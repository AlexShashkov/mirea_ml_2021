# -*- coding: utf-8 -*-
"""6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c-SpGu_YOtY6x9l4XBghgExAb_fKxmps
"""

!pip uninstall pandas-profiling
!pip install pandas-profiling

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
 
import pandas_profiling

from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN

from pandas_profiling import ProfileReport

from google.colab import drive
drive.mount('/content/drive')

data = pd.read_csv('/content/drive/MyDrive/oec.csv')

"""# I. Обработка данных"""

mdata = data
mdata["PlanetaryMassJpt"][141]  -= 90
mdata["PlanetaryMassJpt"][2905]  -= 150
data = mdata

mdata = data
mdata[mdata.RadiusJpt > 2]
mdata["RadiusJpt"][1680]  -= 3
data = mdata

data['PeriodDays'].where(data['PeriodDays'] < 300000, 50000, inplace=True)
data.loc[data.PeriodDays > 300000, 'PeriodDays'] = data.loc[data.PeriodDays > 300000, 'PeriodDays'] - 25000
data.loc[data.PeriodDays > 50000, 'PeriodDays'] = data.loc[data.PeriodDays > 50000, 'PeriodDays'] - 50000
data.loc[data.PeriodDays > 140000, 'PeriodDays'] = 40000
data.loc[data.PeriodDays > 100000, 'PeriodDays'] = 30000

data.loc[data.SemiMajorAxisAU > 50, 'SemiMajorAxisAU'] = data.loc[data.SemiMajorAxisAU > 50, 'SemiMajorAxisAU'] / 50
data.loc[data.SemiMajorAxisAU > 20, 'SemiMajorAxisAU'] = data.loc[data.SemiMajorAxisAU > 20, 'SemiMajorAxisAU'] / 20
data.loc[data.SemiMajorAxisAU > 5, 'SemiMajorAxisAU'] = data.loc[data.SemiMajorAxisAU > 5, 'SemiMajorAxisAU'] / 10

data.loc[data.Eccentricity > 0.4, 'Eccentricity'] = data.loc[data.Eccentricity > 0.4, 'Eccentricity'] - 0.5

data.loc[data.PeriastronDeg < 200, 'PeriastronDeg'] = data.loc[data.PeriastronDeg < 200, 'PeriastronDeg'] + 100
data.loc[data.PeriastronDeg > 700, 'PeriastronDeg'] = data.loc[data.PeriastronDeg > 700, 'PeriastronDeg'] - 500

data.loc[data.InclinationDeg < 70, 'InclinationDeg'] = data.loc[data.InclinationDeg < 70, 'InclinationDeg'] + 30
data.loc[data.InclinationDeg < 70, 'InclinationDeg'] = data.loc[data.InclinationDeg < 70, 'InclinationDeg'] + 30
data.loc[data.InclinationDeg < 70, 'InclinationDeg'] = data.loc[data.InclinationDeg < 70, 'InclinationDeg'] + 30
data.loc[data.InclinationDeg > 300, 'InclinationDeg'] = data.loc[data.InclinationDeg > 300, 'InclinationDeg'] - 160

data.loc[data.SurfaceTempK > 5000, 'SurfaceTempK'] = data.loc[data.SurfaceTempK > 5000, 'SurfaceTempK'] - 4000

data.loc[data.HostStarTempK > 15000, 'HostStarTempK'] = data.loc[data.HostStarTempK > 15000, 'HostStarTempK'] - 17000

data.loc[data.HostStarAgeGyr > 50, 'HostStarAgeGyr'] = data.loc[data.HostStarAgeGyr > 50, 'HostStarAgeGyr'] - 75

data.loc[data.DistFromSunParsec > 2000, 'DistFromSunParsec'] = data.loc[data.DistFromSunParsec > 2000, 'DistFromSunParsec'] - 2000
data.loc[data.DistFromSunParsec > 4000, 'DistFromSunParsec'] = data.loc[data.DistFromSunParsec > 4000, 'DistFromSunParsec'] - 3000
data.loc[data.DistFromSunParsec > 2000, 'DistFromSunParsec'] = data.loc[data.DistFromSunParsec > 2000, 'DistFromSunParsec'] - 2000
data.loc[data.DistFromSunParsec > 1500, 'DistFromSunParsec'] = data.loc[data.DistFromSunParsec > 1500, 'DistFromSunParsec'] - 1500

data.set_index('PlanetIdentifier', inplace=True)

data.TypeFlag = np.where(data.TypeFlag == 0, 1, 0)
data.DiscoveryMethod = np.where(data.DiscoveryMethod == "transit", 1, 0)

def conditions(x):
  lst = [
         "Confirmed planets",
         "Confirmed planets, Planets in binary systems, S-type",
         "Confirmed planets, Planets in binary systems, P-type",
         "Confirmed planets, Planets in open clusters",
         "Solar System", "Kepler Objects of Interest",
         "Confirmed planets, Orphan planets",
         "Planets in binary systems, S-type, Confirmed planets",
         "Confirmed planets, Planets in binary systems, P-type, Planets in globular clusters"
  ]
  if x in lst:
      return 1
  else:
      return 0

func = np.vectorize(conditions)
data['ListsPlanetIsOn'] = func(data['ListsPlanetIsOn'])

data = data.drop('DiscoveryYear', 1)
data = data.drop('LastUpdated', 1)

origdata = data

"""# II. Кластеризация со столбцами долготы"""

dolgdata = origdata
dolgdata = dolgdata.drop(columns=dolgdata.loc[:, dolgdata.count() < 3584/2].columns)

dolgdata["Dec1"] = np.NaN
dolgdata["Dec2"] = np.NaN
dolgdata["Dec3"] = np.NaN

for i in range(dolgdata.shape[0]):
    x = dolgdata['Declination'].iloc[i]
    if x != x:
        dolgdata.loc[dolgdata.index[i], 'Dec1'] = np.NaN
        dolgdata.loc[dolgdata.index[i], 'Dec2'] = np.NaN
        dolgdata.loc[dolgdata.index[i], 'Dec3'] = np.NaN
    else:
        x = x.split(' ')
        dolgdata.loc[dolgdata.index[i], 'Dec1'] = float(x[0])
        dolgdata.loc[dolgdata.index[i], 'Dec2'] = float(x[1])
        dolgdata.loc[dolgdata.index[i], 'Dec3'] = float(x[2])

dolgdata = dolgdata.drop('Declination', 1)
dolgdata['Dec1'].fillna(value=np.mean(dolgdata['Dec1']),inplace=True)
dolgdata['Dec2'].fillna(value=np.mean(dolgdata['Dec2']),inplace=True)
dolgdata['Dec3'].fillna(value=np.mean(dolgdata['Dec3']),inplace=True)

dolgdata["Ra1"] = np.NaN
dolgdata["Ra2"] = np.NaN
dolgdata["Ra3"] = np.NaN

for i in range(dolgdata.shape[0]):
    x = dolgdata['RightAscension'].iloc[i]
    if x != x:
        dolgdata.loc[dolgdata.index[i], 'Ra1'] = np.NaN
        dolgdata.loc[dolgdata.index[i], 'Ra2'] = np.NaN
        dolgdata.loc[dolgdata.index[i], 'Ra3'] = np.NaN
    else:
        x = x.split(' ')
        dolgdata.loc[dolgdata.index[i], 'Ra1'] = float(x[0])
        dolgdata.loc[dolgdata.index[i], 'Ra2'] = float(x[1])
        dolgdata.loc[dolgdata.index[i], 'Ra3'] = float(x[2])

dolgdata = dolgdata.drop('RightAscension', 1)
dolgdata['Ra1'].fillna(value=np.mean(dolgdata['Ra1']),inplace=True)
dolgdata['Ra2'].fillna(value=np.mean(dolgdata['Ra2']),inplace=True)
dolgdata['Ra3'].fillna(value=np.mean(dolgdata['Ra3']),inplace=True)

dolgdata['PeriodDays'].fillna(np.mean(dolgdata['PeriodDays']), inplace=True)
dolgdata['DistFromSunParsec'].fillna(np.mean(dolgdata['DistFromSunParsec']), inplace=True)
dolgdata['HostStarMassSlrMass'].fillna(np.mean(dolgdata['HostStarMassSlrMass']), inplace=True)
dolgdata['HostStarRadiusSlrRad'].fillna(np.mean(dolgdata['HostStarRadiusSlrRad']), inplace=True)
dolgdata['HostStarMetallicity'].fillna(np.mean(dolgdata['HostStarMetallicity']), inplace=True)
dolgdata['HostStarTempK'].fillna(np.mean(dolgdata['HostStarTempK']), inplace=True)
dolgdata['RadiusJpt'].fillna(np.mean(dolgdata['RadiusJpt']), inplace=True)

dolgdata.RadiusJpt = (dolgdata.RadiusJpt - dolgdata.RadiusJpt.mean()) / dolgdata.RadiusJpt.std()

dolgdata.PeriodDays = (dolgdata.PeriodDays - dolgdata.PeriodDays.mean()) / dolgdata.PeriodDays.std()
dolgdata.DistFromSunParsec = (dolgdata.DistFromSunParsec - dolgdata.DistFromSunParsec.mean()) / dolgdata.DistFromSunParsec.std()
dolgdata.HostStarRadiusSlrRad = (dolgdata.HostStarRadiusSlrRad - dolgdata.HostStarRadiusSlrRad.mean()) / dolgdata.HostStarRadiusSlrRad.std()
dolgdata.HostStarTempK = (dolgdata.HostStarTempK - dolgdata.HostStarTempK.mean()) / dolgdata.HostStarTempK.std()

dolgdata.Ra1 = (dolgdata.Ra1 - dolgdata.Ra1.mean()) / dolgdata.Ra1.std()
dolgdata.Ra2 = (dolgdata.Ra2 - dolgdata.Ra1.mean()) / dolgdata.Ra2.std()
dolgdata.Ra3 = (dolgdata.Ra3 - dolgdata.Ra1.mean()) / dolgdata.Ra3.std()

dolgdata.Dec1 = (dolgdata.Dec1 - dolgdata.Dec1.mean()) / dolgdata.Dec1.std()
dolgdata.Dec2 = (dolgdata.Dec2 - dolgdata.Dec2.mean()) / dolgdata.Dec2.std()
dolgdata.Dec3 = (dolgdata.Dec3 - dolgdata.Dec3.mean()) / dolgdata.Dec3.std()

dolgdata.Ra1 = (dolgdata.Ra1 - dolgdata.Ra1.mean()) / dolgdata.Ra1.std()
dolgdata.Ra2 = (dolgdata.Ra2 - dolgdata.Ra1.mean()) / dolgdata.Ra2.std()
dolgdata.Ra3 = (dolgdata.Ra3 - dolgdata.Ra1.mean()) / dolgdata.Ra3.std()

dolgdata.Dec1 = (dolgdata.Dec1 - dolgdata.Dec1.mean()) / dolgdata.Dec1.std()
dolgdata.Dec2 = (dolgdata.Dec2 - dolgdata.Dec2.mean()) / dolgdata.Dec2.std()
dolgdata.Dec3 = (dolgdata.Dec3 - dolgdata.Dec3.mean()) / dolgdata.Dec3.std()

pandas_profiling.ProfileReport(dolgdata)

"""## Снижение размерности"""

pca = PCA()
pca.fit(dolgdata)
X_pca = pca.transform(dolgdata)

for i, component in enumerate(pca.components_):
    print("{} component: {}% of initial variance".format(i + 1, 
          round(100 * pca.explained_variance_ratio_[i], 2)))
    print(" + ".join("%.3f x %s" % (value, name)
                     for value, name in zip(component, dolgdata.columns)))

plt.figure(figsize=(10,10))
plt.plot(np.cumsum(pca.explained_variance_ratio_), color='k', lw=2)
plt.axhline(0.9, c='r')
plt.axvline(8, c='b')

plt.plot(7.3, 0.9, 'gX')

plt.xlabel('Количество признаков')
plt.ylabel('Описание дисперсии')

"""# III. Кластеризация без столбцов долготы"""

data2 = origdata

data2.PeriodDays = (data2.PeriodDays - data2.PeriodDays.mean()) / data2.PeriodDays.std()
data2.DistFromSunParsec = (data2.DistFromSunParsec - data2.DistFromSunParsec.mean()) / data2.DistFromSunParsec.std()
data2.HostStarRadiusSlrRad = (data2.HostStarRadiusSlrRad - data2.HostStarRadiusSlrRad.mean()) / data2.HostStarRadiusSlrRad.std()
data2.HostStarTempK = (data2.HostStarTempK - data2.HostStarTempK.mean()) / data2.HostStarTempK.std()

data2 = data2.drop(columns=data2.loc[:, data2.count() < 3584/2].columns)

data2['RadiusJpt'].fillna(np.mean(data2['RadiusJpt']), inplace=True)
data2['PeriodDays'].fillna(np.mean(data2['PeriodDays']), inplace=True)
data2['DistFromSunParsec'].fillna(np.mean(data2['DistFromSunParsec']), inplace=True)
data2['HostStarMassSlrMass'].fillna(np.mean(data2['HostStarMassSlrMass']), inplace=True)
data2['HostStarRadiusSlrRad'].fillna(np.mean(data2['HostStarRadiusSlrRad']), inplace=True)
data2['HostStarMetallicity'].fillna(np.mean(data2['HostStarMetallicity']), inplace=True)
data2['HostStarTempK'].fillna(np.mean(data2['HostStarTempK']), inplace=True)

data2 = data2.drop("RightAscension", 1)

data2 = data2.drop("Declination", 1)

pca = PCA()
pca.fit(data2)
X_pca = pca.transform(data2)

for i, component in enumerate(pca.components_):
    print("{} component: {}% of initial variance".format(i + 1, 
          round(100 * pca.explained_variance_ratio_[i], 2)))
    print(" + ".join("%.3f x %s" % (value, name)
                     for value, name in zip(component, data2.columns)))

X_pca[:, :3].shape

plt.figure(figsize=(10,10))
plt.plot(np.cumsum(pca.explained_variance_ratio_), color='k', lw=2)
plt.axhline(0.9, c='r')
plt.axvline(3, c='b')

plt.plot(7.3, 0.9, 'gX')

plt.xlabel('Количество признаков')
plt.ylabel('Описание дисперсии')

"""Вместо pyplot используем plotly """

import plotly.express as px
import plotly.graph_objects as go

fig = px.scatter_3d(X_pca[:, :3], x=0, y=1, z=2, size_max=18, opacity=0.7)
fig.show()

from sklearn.cluster import KMeans

inertia = []
for k in range(1, 20):
    kmeans_iter = KMeans(n_clusters=k, random_state=42).fit(data2)
    inertia.append(np.sqrt(kmeans_iter.inertia_))

plt.plot(range(1, 20), inertia, marker='s');
plt.xlabel("Число кластеров")
plt.ylabel("Cумма квадратов расстояний\nот точек до центроидов");

kmeans = KMeans(n_clusters=10, random_state=42)

# Проводим моделирование
kmeans.fit(data2)
all_predictions = kmeans.predict(data2)

fig = px.scatter_3d(X_pca[:, :3], x=0, y=1, z=2, size_max=18, opacity=0.7, color=all_predictions)
fig.show()

fig = px.scatter_3d(solar, x='0', y='1', z='2', size_max=18, opacity=0.7, color = "class", text= "name")
fig.show()



result = X_pca
solar_indexes = [data2.index.get_loc("Earth"), data2.index.get_loc("Mercury"), data2.index.get_loc("Venus"),
                 data2.index.get_loc("Mars"), data2.index.get_loc("Jupiter"), data2.index.get_loc("Saturn"),
                 data2.index.get_loc("Uranus"), data2.index.get_loc("Neptune"), data2.index.get_loc("Pluto")]
solar_name = ["Earth", "Mercury", "Venus", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"]


earth = result[data2.index.get_loc("Earth")]
mercury = result[data2.index.get_loc("Mercury")]
    
venus = result[data2.index.get_loc("Venus")]
    
mars = result[data2.index.get_loc("Mars")]
jupiter = result[data2.index.get_loc("Jupiter")]
    
saturn = result[data2.index.get_loc("Saturn")]
    
uranus = result[data2.index.get_loc("Uranus")]
    
neptune = result[data2.index.get_loc("Neptune")]
    
pluto = result[data2.index.get_loc("Pluto")]

solar = np.array([earth, mercury, venus, mars, jupiter, saturn, uranus, neptune, pluto])

solar = pd.DataFrame({'0': solar[:, 0], '1': solar[:, 1], '2':solar[:, 2]})

solar["index"] = np.NaN
solar["class"] = np.NaN
solar["name"] = np.NaN

for i in range(solar.shape[0]):
    solar["index"].iloc[i] = solar_indexes[i] 
    solar['class'].iloc[i] = all_predictions[i]
    solar["name"].iloc[i] = solar_name[i]

solar

clusters = {}

all_predictions

for i in range(data2.shape[0]):
    color = all_predictions[i]
    if clusters.get(color, False): clusters[color].append(data2.index[i])
    else: clusters[color] = [data2.index[i]]

clusters.keys()

data2.loc[clusters[2], :]

ProfileReport(data2.loc[clusters[0], :])

ProfileReport(data2.loc[clusters[1], :])

ProfileReport(data2.loc[clusters[2], :])

ProfileReport(data2.loc[clusters[3], :])

ProfileReport(data2.loc[clusters[4], :])

ProfileReport(data2.loc[clusters[5], :])

ProfileReport(data2.loc[clusters[6], :])

ProfileReport(data2.loc[clusters[7], :])

ProfileReport(data2.loc[clusters[8], :])

ProfileReport(data2.loc[clusters[9], :])

clusters[7]

"""# IV. Кластеризация с использованием столбцов массы

Отдельно стоит рассмотреть кластеризацию, вернув столбцы у которых потеря данных составляет более 50%. Избавимся от строк с недостоющими данными
"""

massdata = origdata

massdata = massdata[massdata['PlanetaryMassJpt'].notna()]

massdata

massdata = massdata.drop(massdata.loc[:, massdata.count() < 1313/2].columns, 1)

massdata

massdata['PeriodDays'].fillna(np.mean(massdata['PeriodDays']), inplace=True)
massdata['DistFromSunParsec'].fillna(np.mean(massdata['DistFromSunParsec']), inplace=True)
massdata['HostStarMassSlrMass'].fillna(np.mean(massdata['HostStarMassSlrMass']), inplace=True)
massdata['HostStarRadiusSlrRad'].fillna(np.mean(massdata['HostStarRadiusSlrRad']), inplace=True)
massdata['HostStarMetallicity'].fillna(np.mean(massdata['HostStarMetallicity']), inplace=True)
massdata['HostStarTempK'].fillna(np.mean(massdata['HostStarTempK']), inplace=True)
massdata['Eccentricity'].fillna(np.mean(massdata['Eccentricity']), inplace=True)
massdata['SurfaceTempK'].fillna(np.mean(massdata['SurfaceTempK']), inplace=True)
massdata['SemiMajorAxisAU'].fillna(np.mean(massdata['SemiMajorAxisAU']), inplace=True)

massdata.isna().any()

massdata = massdata.drop("RightAscension", 1)
massdata = massdata.drop("Declination", 1)

massdata = massdata.drop("Eccentricity", 1)

massdata = massdata.drop("DiscoveryMethod", 1)

massdata = massdata.drop("ListsPlanetIsOn", 1)

massdata = massdata.drop("TypeFlag", 1)

massdata = massdata.drop("SemiMajorAxisAU", 1)

ProfileReport(massdata)

massdata.PeriodDays = (massdata.PeriodDays - massdata.PeriodDays.mean()) / massdata.PeriodDays.std()
massdata.DistFromSunParsec = (massdata.DistFromSunParsec - massdata.DistFromSunParsec.mean()) / massdata.DistFromSunParsec.std()
massdata.HostStarRadiusSlrRad = (massdata.HostStarRadiusSlrRad - massdata.HostStarRadiusSlrRad.mean()) / massdata.HostStarRadiusSlrRad.std()
massdata.HostStarTempK = (massdata.HostStarTempK - massdata.HostStarTempK.mean()) / massdata.HostStarTempK.std()
massdata.SurfaceTempK = (massdata.SurfaceTempK - massdata.SurfaceTempK.mean()) / massdata.SurfaceTempK.std()
massdata.HostStarMetallicity = (massdata.HostStarMetallicity - massdata.HostStarMetallicity.mean()) / massdata.HostStarMetallicity.std()
massdata.HostStarMassSlrMass = (massdata.HostStarMassSlrMass - massdata.HostStarMassSlrMass.mean()) / massdata.HostStarMassSlrMass.std()
massdata.PlanetaryMassJpt = (massdata.PlanetaryMassJpt - massdata.PlanetaryMassJpt.mean()) / massdata.PlanetaryMassJpt.std()
massdata.SemiMajorAxisAU = (massdata.SemiMajorAxisAU - massdata.SemiMajorAxisAU.mean()) / massdata.SemiMajorAxisAU.std()
massdata.Eccentricity = (massdata.Eccentricity - massdata.Eccentricity.mean()) / massdata.Eccentricity.std()

pca = PCA()
pca.fit(massdata)
X_pca = pca.transform(massdata)

for i, component in enumerate(pca.components_):
    print("{} component: {}% of initial variance".format(i + 1, 
          round(100 * pca.explained_variance_ratio_[i], 2)))
    print(" + ".join("%.3f x %s" % (value, name)
                     for value, name in zip(component, massdata.columns)))

plt.figure(figsize=(10,10))
plt.plot(np.cumsum(pca.explained_variance_ratio_), color='k', lw=2)
plt.axhline(0.9, c='r')
plt.axvline(7, c='b')

plt.xlabel('Количество признаков')
plt.ylabel('Описание дисперсии')